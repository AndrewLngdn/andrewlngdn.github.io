---
layout: none
title: "Visualizing Adam's adaptive learning rates"
description: "Interactive visualization demonstrating how the Adam optimization algorithm adapts learning rates based on different gradient patterns"
og_image: /adam_scaling/preview.jpg
og_image_alt: "Adam optimizer visualization showing adaptive learning rates"
---
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizing Adam's adaptive learning rates</title>

    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:title" content="Visualizing Adam's adaptive learning rates" />
    <meta property="og:description" content="Interactive visualization demonstrating how the Adam optimization algorithm adapts learning rates based on different gradient patterns" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://andrewlngdn.github.io/adam_scaling/" />
    <meta property="og:image" content="https://andrewlngdn.github.io/adam_scaling/preview.jpg" />
    <meta property="og:image:alt" content="Adam optimizer visualization showing adaptive learning rates" />

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Visualizing Adam's adaptive learning rates" />
    <meta name="twitter:description" content="Interactive visualization demonstrating how the Adam optimization algorithm adapts learning rates based on different gradient patterns" />
    <meta name="twitter:image" content="https://andrewlngdn.github.io/adam_scaling/preview.jpg" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        /* CSS Reset & Base Styles */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 1rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #1a1a1a;
            background: #fff;
        }

        /* Container */
        .container {
            max-width: 720px;
            margin: 0 auto;
        }

        /* Typography */
        h1, h2, h3 {
            margin: 0 0 1rem 0;
            font-weight: 600;
            line-height: 1.2;
        }

        h1 { font-size: 2rem; }
        h2 { font-size: 1.5rem; }
        h3 { font-size: 1.25rem; }

        p {
            margin: 0 0 1rem 0;
        }

        a {
            color: #007bff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        /* Buttons */
        button, a[role="button"] {
            display: inline-block;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            font-weight: 500;
            text-decoration: none;
            color: #007bff;
            background: transparent;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }

        button:hover, a[role="button"]:hover {
            background: #f5f5f5;
            text-decoration: none;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Form inputs */
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #007bff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        /* Articles/Cards */
        article {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        /* Details/Summary */
        details {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
        }

        summary {
            cursor: pointer;
            font-weight: 500;
            user-select: none;
            list-style: none;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        /* Header styles */
        h1 {
            text-align: left;
            margin-bottom: 3rem;
        }

        .subtitle {
            text-align: center;
            opacity: 0.8;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
        }

        /* Control panel layout */
        .control-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .control-item label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            margin-bottom: 0.25rem;
        }

        .control-item .value {
            font-weight: bold;
            font-family: monospace;
        }

        .buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .buttons button {
            margin: 0;
        }

        .iteration-counter {
            text-align: center;
            font-weight: bold;
            margin-top: 1rem;
        }

        /* Visualization sections */
        .viz-section {
            margin: 2rem 0;
        }

        .viz-section h2 {
            margin-top: 3rem;
            margin-bottom: 1rem;
        }

        .viz-section > p {
            margin-bottom: 1.5rem;
        }

        .viz-card {
            max-width: 900px;
            margin: 1.5rem auto;
        }

        /* Ensure viz cards have proper article styling */
        article.viz-card {
            padding: 1.5rem;
        }

        /* Collapsible controls styling */
        details {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 1rem;
        }

        details summary {
            cursor: pointer;
            user-select: none;
            list-style: none;
        }

        details summary::-webkit-details-marker {
            display: none;
        }

        details summary::before {
            content: '▶ ';
            display: inline-block;
            transition: transform 0.2s;
        }

        details[open] summary::before {
            transform: rotate(90deg);
        }

        .card-main {
            display: flex;
            gap: 20px;
            align-items: stretch;
        }

        .chart-section {
            flex: 1;
            min-width: 0;
        }

        .ratio-section {
            flex: 0 0 240px;
            display: flex;
            align-items: center;
        }

        .ratio-display {
            background: #374151;
            color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            width: 100%;
        }

        .ratio-display .ratio-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .ratio-display .ratio-value {
            font-size: 38px;
            font-weight: bold;
            font-family: monospace;
            margin: 10px 0;
            transition: opacity 0.3s ease;
        }

        .ratio-display .ratio-value.updating {
            opacity: 0.6;
        }

        .ratio-display .ratio-formula {
            font-size: 13px;
            opacity: 0.9;
            margin-top: 5px;
        }

        .ratio-display .ratio-explanation {
            font-size: 10px;
            opacity: 0.85;
            margin-top: 8px;
            font-style: italic;
        }

        .chart-container {
            position: relative;
            height: 220px;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 11px;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
        }

        .metric {
            display: flex;
            flex-direction: column;
        }

        .metric-label {
            color: #666;
            font-weight: 500;
        }

        .metric-value {
            font-family: monospace;
            font-weight: bold;
            color: #333;
            font-size: 12px;
            transition: opacity 0.3s ease, transform 0.2s ease;
        }

        .metric-value.updating {
            opacity: 0.6;
            transform: translateX(2px);
        }

        .equation {
            background: #fff3cd;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-family: monospace;
            font-size: 12px;
            text-align: center;
            border: 1px solid #ffc107;
        }

        .iteration-counter {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        /* Very small screens (iPhone SE, etc.) */
        @media (max-width: 400px) {
            nav {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            nav > div {
                width: 100%;
                justify-content: space-between;
            }

            nav a[role="button"] {
                padding: 0.35rem 0.5rem;
                font-size: 0.8rem;
            }
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            body {
                padding: 0.5rem;
            }

            .container {
                max-width: 100%;
            }

            nav {
                flex-wrap: wrap;
                gap: 0.5rem;
            }

            nav > div {
                display: flex;
                flex-direction: row;
                gap: 0.5rem;
            }

            nav a[role="button"] {
                padding: 0.4rem 0.7rem;
                font-size: 0.85rem;
            }

            .viz-card {
                max-width: 100%;
            }

            .card-main {
                flex-direction: column;
            }

            .ratio-section {
                flex: 1;
                width: 100%;
            }

            .chart-container {
                height: 200px;
            }

            .control-group {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.5rem;
            }

            .viz-section h2 {
                font-size: 1.25rem;
            }
        }
    </style>
</head>
<body>
    <main class="container">
        <nav style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <span style="font-weight: 500;"><a href="/" style="color: inherit; text-decoration: none;">Andrew Langdon</a></span>
            <div style="display: flex; gap: 0.5rem;">
                <a href="mailto:andrewlngdn@gmail.com" role="button">Contact</a>
                <a href="https://www.linkedin.com/in/andrew-langdon-583b1952/" role="button" target="_blank">LinkedIn</a>
                <a href="/Andrew_Langdon_resume_2pg_nov_2025.pdf" role="button" target="_blank">Resume</a>
            </div>
        </nav>

        <h1>Visualizing Adam's adaptive learning rates</h1>
        <p style="text-align: left; opacity: 0.6; font-size: 0.85rem; margin-top: 0; margin-bottom: 1rem;">November 3, 2025</p>

        <p>If you've trained a machine learning model in the past, there's a good chance you've optimized with Adam. A big reason for Adam's success is that it determines individual learning rates for each model parameter, making large updates when confident, and small updates when uncertain.</p>

        <p style="font-style: italic; margin: 1rem 0 1.5rem 0; opacity: 0.85; font-size: 0.95rem;">
            Watch how Adam adapts its step sizes in real-time. (We'll explain what you're seeing in a moment.)
        </p>
        <div id="viz-hero" style="margin-bottom: 3rem;"></div>

        <p>Adam keeps two running statistics for each parameter:</p>

        <ol style="margin-bottom: 1rem;">
            <li>a moving average of past gradients, capturing gradient trend, and</li>
            <li>a moving average of the squared gradients, capturing gradient intensity</li>
        </ol>

        <p>The first changes slowly, filtering out noise. "Uncertain" gradients that bounce around zero will average out near zero, while consistent gradients remain either positive or negative. The second captures gradient intensity. Dividing the average by this intensity gives a value typically between 0 and 1. Adam uses this scaling factor to attenuate the global learning rate for each individual parameter.</p>

        <p>Instead of starting bottom-up with the full set of equations, let's analyze top-down by looking at the full system behavior.</p>

        <p>Here's the Adam parameter update rule:</p>

        <p style="text-align: center; font-size: 1.2em; margin: 1.5rem 0;">
            $$\theta_{t+1} = \theta_t - \eta \frac{\hat{m}_t}{\sqrt{\hat{v}_t} + \epsilon}$$
        </p>

        <p>$\hat{m}_t$ is the moving average of our gradients, and $\sqrt{\hat{v}_t}$ is the square root of our squared gradients. Taking the square root normalizes the denominator to the same scale as the numerator.</p>

        <p>We will be focusing on that ratio, $\hat{m}_t / (\sqrt{\hat{v}_t} + \epsilon)$, which we will call the <strong>learning-rate scale</strong>. It determines how much of the global learning rate $\eta$ is effectively applied to each parameter.</p>

        <p>The complete update rule can be found in the Adam publication: <a href="https://arxiv.org/pdf/1412.6980" target="_blank">https://arxiv.org/pdf/1412.6980</a>.</p>

        <p style="margin-top: 2rem;">We can simulate different gradient patterns to see how they change the effective learning rate. In the below visualizations, the gradients are represented by a lollipop icon, the moving average $\hat{m}_t$ is shown in blue, and $\sqrt{\hat{v}_t}$ is shown in orange.</p>

        <section class="viz-section">
            <h2>Consistent Direction</h2>
            <p>When the gradients consistently say, "raise this parameter for better performance", Adam's moving average builds confidence. The learning-rate scale remains close to one, and the parameter makes larger updates:</p>
            <div id="viz-consistent"></div>
        </section>

        <section class="viz-section">
            <h2>Noisy Gradients</h2>
            <p>If the gradients are inconsistent around zero, the optimizer becomes more cautious. Imagine hearing, "lower this, wait, now raise it, ok now lower again, wait…". In this case, we'd want to avoid big steps and instead make smaller adjustments. The learning-rate scale diminishes, which means smaller, fine-tuned update steps:</p>
            <div id="viz-noisy"></div>
        </section>

        <section class="viz-section">
            <h2>Trend Reversals</h2>
            <p>When gradient directions flip after being consistent, the scale briefly drops, then rebuilds as a new trend forms. This helps prevent overshooting and stabilizes learning:</p>
            <div id="viz-oscillating"></div>
        </section>

        <p style="margin-top: 3rem;">Adam's adaptive behavior is why it works so well on complex, high-dimensional surfaces: it learns how much to trust its own gradients.</p>

        <p style="margin-top: 3rem;">If you want to see a visualization about something ML-related, contact me at <a href="mailto:andrewlngdn@gmail.com">andrewlngdn@gmail.com</a>. See ya!</p>

        <figure style="margin: 2rem auto; text-align: center; max-width: 300px;">
            <img src="frankie_path.jpeg" alt="Dog running erratically" style="max-width: 100%; height: auto; border-radius: 8px;">
            <figcaption style="margin-top: 0.5rem; font-style: italic; opacity: 0.8; font-size: 0.9rem;">
                Frankie often sprints in a random direction when I pick up his ball, overreacting to a noisy signal.
            </figcaption>
        </figure>

        <footer style="margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #ddd;">
        </footer>

        <details style="margin-top: 2rem;">
            <summary><strong>Advanced Controls</strong></summary>
            <div style="margin-top: 1rem;">
                <div class="control-group">
                <div class="control-item">
                    <label>
                        <span>Learning Rate (α)</span>
                        <span class="value" id="alpha-value">0.01</span>
                    </label>
                    <input type="range" id="alpha" min="0.001" max="0.1" step="0.001" value="0.01">
                </div>
                <div class="control-item">
                    <label>
                        <span>Beta 1 (β₁) - Momentum Decay</span>
                        <span class="value" id="beta1-value">0.9</span>
                    </label>
                    <input type="range" id="beta1" min="0.5" max="0.99" step="0.01" value="0.9">
                </div>
                <div class="control-item">
                    <label>
                        <span>Beta 2 (β₂) - Variance Decay</span>
                        <span class="value" id="beta2-value">0.999</span>
                    </label>
                    <input type="range" id="beta2" min="0.9" max="0.9999" step="0.0001" value="0.999">
                </div>
                <div class="control-item">
                    <label>
                        <span>Epsilon (ε) - Stability Constant</span>
                        <span class="value" id="epsilon-value">1e-8</span>
                    </label>
                    <input type="range" id="epsilon" min="1e-10" max="1e-6" step="1e-10" value="1e-8">
                </div>
                <div class="control-item">
                    <label>
                        <span>Animation Speed</span>
                        <span class="value" id="speed-value">400ms</span>
                    </label>
                    <input type="range" id="speed" min="100" max="1000" step="50" value="400">
                </div>
            </div>
            <div class="buttons">
                <button id="play-btn">▶ Play</button>
                <button id="pause-btn" disabled>⏸ Pause</button>
                <button id="step-btn">⏭ Step</button>
                <button id="reset-btn" class="outline">↻ Reset</button>
            </div>
            <div class="iteration-counter">Iteration: <span id="iteration">0</span></div>
            </div>
        </details>
    </main>

    <script>
        // Gradient pattern generators
        const gradientPatterns = {
            heroPattern: {
                name: "Hero Visualization",
                description: "Subtle sine wave with noise",
                generate: (t) => 0.5 * Math.cos(t * 0.25) + (Math.random() - 0.5) * 0.4
            },
            consistentDirection: {
                name: "Consistent Direction",
                description: "Gradients point in same direction with some noise",
                generate: (t) => 0.9 + (Math.random() - 0.5) * 1.0
            },
            noisy: {
                name: "Noisy Gradients",
                description: "Random noise around zero",
                generate: (t) => (Math.random() - 0.5) * 2.4
            },
            oscillating: {
                name: "Trend Reversals",
                description: "Oscillation with noise crossing zero",
                generate: (t) => 1.2 * Math.sin(t * 0.2) + (Math.random() - 0.5) * 0.3
            }
        };

        // Adam optimizer implementation
        class AdamOptimizer {
            constructor(alpha = 0.01, beta1 = 0.9, beta2 = 0.999, epsilon = 1e-8) {
                this.alpha = alpha;
                this.beta1 = beta1;
                this.beta2 = beta2;
                this.epsilon = epsilon;
                this.reset();
            }

            reset() {
                this.m = 0;  // First moment
                this.v = 0;  // Second moment
                this.t = 0;  // Time step
                this.theta = 0;  // Parameter value
            }

            update(gradient) {
                this.t += 1;

                // Update biased first moment estimate
                this.m = this.beta1 * this.m + (1 - this.beta1) * gradient;

                // Update biased second moment estimate
                this.v = this.beta2 * this.v + (1 - this.beta2) * gradient * gradient;

                // Compute bias-corrected first moment
                const m_hat = this.m / (1 - Math.pow(this.beta1, this.t));

                // Compute bias-corrected second moment
                const v_hat = this.v / (1 - Math.pow(this.beta2, this.t));

                // Compute square root of v_hat
                const sqrt_v_hat = Math.sqrt(v_hat) + this.epsilon;

                // Compute the ratio (this is what scales the gradient)
                const ratio = m_hat / sqrt_v_hat;

                // Compute effective learning rate
                const effective_lr = this.alpha / sqrt_v_hat;

                // Update parameter
                const update = this.alpha * ratio;
                this.theta -= update;

                return {
                    gradient: gradient,
                    m: this.m,
                    v: this.v,
                    m_hat: m_hat,
                    v_hat: v_hat,
                    sqrt_v_hat: sqrt_v_hat,
                    ratio: ratio,
                    effective_lr: effective_lr,
                    update: update,
                    theta: this.theta
                };
            }

            updateHyperparameters(alpha, beta1, beta2, epsilon) {
                this.alpha = alpha;
                this.beta1 = beta1;
                this.beta2 = beta2;
                this.epsilon = epsilon;
            }
        }

        // Global state
        let iteration = 0;
        let isPlaying = false;
        let animationId = null;
        let maxHistory = window.innerWidth < 768 ? 20 : 40;
        const parameters = [];

        // Update maxHistory on window resize
        window.addEventListener('resize', () => {
            const newMaxHistory = window.innerWidth < 768 ? 20 : 40;
            if (newMaxHistory !== maxHistory) {
                maxHistory = newMaxHistory;
                // Trim existing history if needed
                parameters.forEach(param => {
                    Object.keys(param.history).forEach(key => {
                        if (param.history[key].length > maxHistory) {
                            param.history[key] = param.history[key].slice(-maxHistory);
                        }
                    });
                });
            }
        });

        // Create parameter visualizations
        function createParameterCard(patternKey, pattern) {
            const optimizer = new AdamOptimizer();
            const history = {
                gradients: [],
                m_values: [],
                v_values: [],
                m_hat_values: [],
                v_hat_values: [],
                sqrt_v_hat_values: [],
                ratio_values: [],
                effective_lr: [],
                theta_values: []
            };

            const card = document.createElement('article');
            card.className = 'viz-card';
            card.innerHTML = `
                <div class="card-main">
                    <div class="chart-section">
                        <div class="chart-container">
                            <canvas id="chart-${patternKey}"></canvas>
                        </div>
                    </div>
                    <div class="ratio-section">
                        <div class="ratio-display">
                            <div class="ratio-label">Learning-Rate Scale</div>
                            <div class="ratio-value" id="${patternKey}-ratio">0.00</div>
                            <div style="margin-top: 15px; font-size: 11px; line-height: 1.8;" id="${patternKey}-formula-container">
                                $$\\mathrm{scale} = \\frac{\\color{#36a2eb}{\\hat{m}_t}}{\\color{#ff9f40}{\\sqrt{\\hat{v}_t}} + \\epsilon} = \\frac{\\color{#36a2eb}{0.00}}{\\color{#ff9f40}{0.00}}$$
                            </div>
                            <span id="${patternKey}-gradient" style="display:none;">0.00</span>
                            <span id="${patternKey}-m-hat" style="display:none;">0.00</span>
                            <span id="${patternKey}-sqrt-v" style="display:none;">0.00</span>
                        </div>
                    </div>
                </div>
            `;

            // Append to specific container based on pattern key
            const containerId = `viz-${patternKey}`;
            const container = document.getElementById(containerId);
            if (container) {
                container.appendChild(card);
            }

            // Create chart
            const ctx = document.getElementById(`chart-${patternKey}`).getContext('2d');
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Gradients',
                            data: [],
                            borderColor: 'rgba(60, 60, 60, 0.9)',
                            backgroundColor: 'rgba(60, 60, 60, 0.9)',
                            pointRadius: 2.5,
                            pointHoverRadius: 3,
                            showLine: false
                        },
                        {
                            label: 'Smoothed trend (m̂ₜ)',
                            data: [],
                            borderColor: 'rgb(54, 162, 235)',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0.4
                        },
                        {
                            label: 'Intensity (√v̂ₜ)',
                            data: [],
                            borderColor: 'rgb(255, 159, 64)',
                            backgroundColor: 'rgba(255, 159, 64, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0.4
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 200,
                        easing: 'easeInOutQuad'
                    },
                    scales: {
                        x: {
                            display: true,
                            border: {
                                display: false
                            },
                            title: {
                                display: true,
                                text: 'Time',
                                font: { size: 11 }
                            },
                            ticks: {
                                display: false
                            },
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            min: -2,
                            max: 2,
                            ticks: {
                                font: { size: 10 },
                                stepSize: 1,
                                callback: function(value) {
                                    // Only show -1, 0, 1 (hide -2 and 2)
                                    if (value === -2 || value === 2) return '';
                                    return value;
                                }
                            },
                            grid: {
                                color: (context) => {
                                    // Make the zero line stand out
                                    if (context.tick.value === 0) {
                                        return 'rgba(0, 0, 0, 0.35)';
                                    }
                                    // Hide gridlines for -2 and 2
                                    if (context.tick.value === -2 || context.tick.value === 2) {
                                        return 'transparent';
                                    }
                                    return 'rgba(0, 0, 0, 0.1)';
                                },
                                lineWidth: (context) => {
                                    if (context.tick.value === 0) {
                                        return 1.5;
                                    }
                                    // Hide gridline for -2 and 2 by setting width to 0
                                    if (context.tick.value === -2 || context.tick.value === 2) {
                                        return 0;
                                    }
                                    return 1;
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                font: { size: 10 },
                                boxWidth: 10,
                                padding: 5
                            }
                        }
                    }
                },
                plugins: [{
                    afterDatasetsDraw: (chart) => {
                        const ctx = chart.ctx;
                        const meta = chart.getDatasetMeta(0); // gradient dataset

                        if (!meta || !meta.data || meta.data.length === 0) return;

                        // Get y-position of zero line
                        const yScale = chart.scales.y;
                        const zeroY = yScale.getPixelForValue(0);

                        // Draw vertical line from zero to each gradient point
                        ctx.save();
                        ctx.strokeStyle = 'rgba(60, 60, 60, 0.3)';
                        ctx.lineWidth = 1.5;

                        meta.data.forEach((point) => {
                            ctx.beginPath();
                            ctx.moveTo(point.x, zeroY);
                            ctx.lineTo(point.x, point.y);
                            ctx.stroke();
                        });

                        ctx.restore();
                    }
                }]
            });

            return { optimizer, history, chart, patternKey, pattern };
        }

        // Initialize all parameters
        function initializeParameters() {
            // Clear existing visualizations
            ['viz-hero', 'viz-consistent', 'viz-noisy', 'viz-oscillating'].forEach(id => {
                const container = document.getElementById(id);
                if (container) container.innerHTML = '';
            });
            parameters.length = 0;

            // Map pattern keys to their container IDs
            const patternMapping = {
                'heroPattern': 'hero',
                'consistentDirection': 'consistent',
                'noisy': 'noisy',
                'oscillating': 'oscillating'
            };

            Object.entries(gradientPatterns).forEach(([key, pattern]) => {
                parameters.push(createParameterCard(patternMapping[key] || key, pattern));
            });
        }

        // Update one step with 3-stage animation
        async function step() {
            iteration++;
            document.getElementById('iteration').textContent = iteration;

            const alpha = parseFloat(document.getElementById('alpha').value);
            const beta1 = parseFloat(document.getElementById('beta1').value);
            const beta2 = parseFloat(document.getElementById('beta2').value);
            const epsilon = parseFloat(document.getElementById('epsilon').value);

            // Collect results for all parameters
            const results = [];
            parameters.forEach(param => {
                param.optimizer.updateHyperparameters(alpha, beta1, beta2, epsilon);
                const gradient = param.pattern.generate(iteration);
                const result = param.optimizer.update(gradient);

                // Store history
                param.history.gradients.push(result.gradient);
                param.history.m_values.push(result.m);
                param.history.v_values.push(result.v);
                param.history.m_hat_values.push(result.m_hat);
                param.history.v_hat_values.push(result.v_hat);
                param.history.sqrt_v_hat_values.push(result.sqrt_v_hat);
                param.history.ratio_values.push(result.ratio);
                param.history.effective_lr.push(result.effective_lr);
                param.history.theta_values.push(result.theta);

                // Limit history length
                if (param.history.gradients.length > maxHistory) {
                    Object.keys(param.history).forEach(key => {
                        param.history[key].shift();
                    });
                }

                results.push({ param, result });
            });

            // STAGE 1: Update charts (triggers Chart.js animation ~200ms)
            results.forEach(({ param }) => {
                const labels = param.history.gradients.map((_, i) => i);
                param.chart.data.labels = labels;
                param.chart.data.datasets[0].data = param.history.gradients;
                param.chart.data.datasets[1].data = param.history.m_hat_values;
                param.chart.data.datasets[2].data = param.history.sqrt_v_hat_values;
                param.chart.update();
            });

            // STAGE 2: Wait for chart animation to complete
            await new Promise(resolve => setTimeout(resolve, 250));

            // STAGE 3: Update metrics with CSS transitions
            results.forEach(({ param, result }) => {
                // Add updating class for transition effect
                const ratioEl = document.getElementById(`${param.patternKey}-ratio`);
                const formulaContainer = document.getElementById(`${param.patternKey}-formula-container`);

                ratioEl.classList.add('updating');

                // Update values with 2 decimal places
                setTimeout(() => {
                    ratioEl.textContent = result.ratio.toFixed(2);

                    // Update the formula with new numeric values
                    const mHatVal = result.m_hat.toFixed(2);
                    const sqrtVVal = result.sqrt_v_hat.toFixed(2);
                    formulaContainer.innerHTML = `$$\\mathrm{scale} = \\frac{\\color{#36a2eb}{\\hat{m}_t}}{\\color{#ff9f40}{\\sqrt{\\hat{v}_t}} + \\epsilon} = \\frac{\\color{#36a2eb}{${mHatVal}}}{\\color{#ff9f40}{${sqrtVVal}}}$$`;

                    // Re-render the LaTeX
                    renderMathInElement(formulaContainer, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false}
                        ]
                    });

                    // Remove updating class
                    setTimeout(() => {
                        ratioEl.classList.remove('updating');
                    }, 300);
                }, 50);
            });

            // Wait for metrics transition to complete
            await new Promise(resolve => setTimeout(resolve, 200));
        }

        // Animation loop
        async function animate() {
            if (!isPlaying) return;
            await step();

            // First 10 iterations: fast (100ms)
            // After that: user's speed setting
            const speed = iteration <= 10
                ? 100
                : parseInt(document.getElementById('speed').value);

            animationId = setTimeout(() => requestAnimationFrame(animate), speed);
        }

        // Control handlers
        document.getElementById('play-btn').addEventListener('click', () => {
            isPlaying = true;
            document.getElementById('play-btn').disabled = true;
            document.getElementById('pause-btn').disabled = false;
            animate();
        });

        document.getElementById('pause-btn').addEventListener('click', () => {
            isPlaying = false;
            document.getElementById('play-btn').disabled = false;
            document.getElementById('pause-btn').disabled = true;
            if (animationId) {
                clearTimeout(animationId);
                animationId = null;
            }
        });

        document.getElementById('step-btn').addEventListener('click', () => {
            step();
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            isPlaying = false;
            document.getElementById('play-btn').disabled = false;
            document.getElementById('pause-btn').disabled = true;
            if (animationId) {
                clearTimeout(animationId);
                animationId = null;
            }
            iteration = 0;
            document.getElementById('iteration').textContent = '0';
            initializeParameters();
        });

        // Slider value updates
        const sliders = ['alpha', 'beta1', 'beta2', 'epsilon', 'speed'];
        sliders.forEach(id => {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(`${id}-value`);
            slider.addEventListener('input', () => {
                const value = parseFloat(slider.value);
                if (id === 'epsilon') {
                    valueDisplay.textContent = value.toExponential(0);
                } else if (id === 'beta2') {
                    valueDisplay.textContent = value.toFixed(4);
                } else if (id === 'speed') {
                    valueDisplay.textContent = Math.round(value) + 'ms';
                } else {
                    valueDisplay.textContent = value.toFixed(3);
                }
            });
        });

        // Initialize on load
        initializeParameters();

        // Render LaTeX
        renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ]
        });

        // Auto-play on load
        setTimeout(() => {
            isPlaying = true;
            document.getElementById('play-btn').disabled = true;
            document.getElementById('pause-btn').disabled = false;
            animate();
        }, 500);
    </script>
</body>
</html>
